#version 450

const float PI = 3.14159265359;
const float HALF_PI = PI / 2.;
const float SQRT2 = sqrt(2);

#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))

#define CIRCULAR_SAMPLE

// layout( local_size_x = 1, local_size_y = 1) in;

layout (push_constant) uniform params_t
{
    mat4 mProjView;
    mat4 mModel;
} params;

layout(binding = 0, set = 0) uniform sampler2D mainView;
layout(binding = 1, set = 0) uniform sampler2D mainViewDepth;
layout(binding = 2, set = 0) writeonly uniform image2D res;

vec3 getWorldPos(vec2 uv) {
    vec4 viewSpace = inverse(params.mProjView) * vec4(uv * 2. - 1., texture(mainViewDepth, uv).x, 1.);
    return viewSpace.xyz / viewSpace.w;
}

void main(){
    ivec2 pixelLocation = ivec2(gl_GlobalInvocationID.xy);
    ivec2 resultSize = ivec2(imageSize(res));

    if (pixelLocation.x >= resultSize.x || pixelLocation.y >= resultSize.y)
    {
        return;
    }

    vec2 uv = (vec2(pixelLocation) + 0.5) / vec2(resultSize);

    vec2 pixOffset = vec2(1.) / vec2(resultSize);

    vec4 initial = texture(mainView, uv);

    vec3 centerPos = getWorldPos(uv);
    vec4 camTmp = inverse(params.mProjView) * vec4(0.0, 0.0, 0.0, 1.0);
    vec3 camPos = camTmp.xyz / camTmp.w;
    vec3 toCamDir = normalize(camPos - centerPos);

    // here is my approach to calculate SSAO
#ifndef CIRCULAR_SAMPLE
    float angleSum = 0.;
    const int N = 1;
    const int W = N * 2 + 1;
    for (int i = -N; i <= N; ++i) {
        for (int j = -N; j <= N; ++j) {
            if (i == 0 && j == 0) {
                continue;
            }
            vec2 offset = pixOffset * vec2(i, j);
            vec3 neighbourDir = normalize(getWorldPos(uv + offset) - centerPos);
            float angleToNegihbour = acos(dot(toCamDir, neighbourDir));
            angleSum += clamp(angleToNegihbour, 0., HALF_PI);
        }
    }
    float ssaoValue = angleSum / (W * W - 1) / HALF_PI;
#else
    const int SAMP_NUM = 6; 
    const float R = SAMP_NUM / PI / 2.;
    vec2 initialOffset = pixOffset * R / SQRT2;
    float angleSum = 0.;
    for (int i = 0; i < SAMP_NUM; ++i) {
        vec2 offset = rot(2. * PI * i / SAMP_NUM) * initialOffset;
        vec3 neighbourDir = normalize(getWorldPos(uv + offset) - centerPos);
        float angleToNegihbour = acos(dot(toCamDir, neighbourDir));
        angleSum += clamp(angleToNegihbour, 0., HALF_PI);
    }
    float ssaoValue = angleSum / SAMP_NUM / HALF_PI;
    
#endif

    imageStore(res, pixelLocation, initial * ssaoValue);
}