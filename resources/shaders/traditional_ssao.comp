#version 450

const float PI = 3.14159265359;
const float D_PI = PI * 2.;
const float HALF_PI = PI / 2.;
const float SQRT2 = sqrt(2);

#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))

#define CIRCULAR_SAMPLE

// layout( local_size_x = 1, local_size_y = 1) in;

layout (push_constant) uniform params_t
{
    mat4 mProjView;
    mat4 mModel;
} params;

layout(binding = 0, set = 0) uniform sampler2D mainViewDepth;
layout(binding = 1, set = 0) writeonly uniform image2D res;

vec3 getWorldPos(vec2 uv) {
    vec4 viewSpace = inverse(params.mProjView) * vec4(uv * 2. - 1., texture(mainViewDepth, uv).x, 1.);
    return viewSpace.xyz / viewSpace.w;
}

// https://www.shadertoy.com/view/4djSRW
//----------------------------------------------------------------------------------------
///  3 out, 3 in...
vec3 hash33(vec3 p3)
{
	p3 = fract(p3 * vec3(.1031, .1030, .0973));
    p3 += dot(p3, p3.yxz+33.33);
    return fract((p3.xxy + p3.yxx)*p3.zyx);
}

//  1 out, 3 in...
float hash13(vec3 p3)
{
	p3  = fract(p3 * .1031);
    p3 += dot(p3, p3.zyx + 31.32);
    return fract((p3.x + p3.y) * p3.z);
}

void main(){
    ivec2 pixelLocation = ivec2(gl_GlobalInvocationID.xy);
    ivec2 resultSize = ivec2(imageSize(res));

    if (pixelLocation.x >= resultSize.x || pixelLocation.y >= resultSize.y)
    {
        return;
    }

    vec2 uv = (vec2(pixelLocation) + 0.5) / vec2(resultSize);

    vec2 pixOffset = vec2(1.) / vec2(resultSize);

    vec3 centerPos = getWorldPos(uv);

    if (texture(mainViewDepth, uv).x > 0.99) {
        // too far
        imageStore(res, pixelLocation, vec4(1.));
        return;
    }

    const int SAMP_NUM = 24;
    const float R = 0.3;
    float cnt = 0.;
    for (int i = 0; i < SAMP_NUM; ++i) {
        vec3 hash = hash33(vec3(pixelLocation, i * i));
        vec3 off = normalize(hash * 2. - 1.) * R * hash13(vec3(pixelLocation, i));
        vec3 offsetted = centerPos + off;
        vec4 ss = params.mProjView * vec4(offsetted, 1.);
        vec3 ndc = ss.xyz / ss.w;
        float viewDepth = texture(mainViewDepth, ndc.xy * 0.5 + 0.5).x;
        cnt += float(ndc.z < viewDepth);
    }
    float ssaoValue = cnt / SAMP_NUM;

    // here is my approach to calculate SSAO
// #ifndef CIRCULAR_SAMPLE
//     float angleSum = 0.;
//     const int N = 1;
//     const int W = N * 2 + 1;
//     for (int i = -N; i <= N; ++i) {
//         for (int j = -N; j <= N; ++j) {
//             if (i == 0 && j == 0) {
//                 continue;
//             }
//             vec2 offset = pixOffset * vec2(i, j);
//             vec3 neighbourDir = normalize(getWorldPos(uv + offset) - centerPos);
//             float angleToNegihbour = acos(dot(toCamDir, neighbourDir));
//             angleSum += clamp(angleToNegihbour, 0., HALF_PI);
//         }
//     }
//     float ssaoValue = angleSum / (W * W - 1) / HALF_PI;
// #else
//     const int SAMP_NUM = 12; 
//     const float R = SAMP_NUM / PI / 2. / (dist / 20.);
//     vec2 initialOffset = pixOffset * R / SQRT2;
//     float angleSum = 0.;
//     for (int i = 0; i < SAMP_NUM; ++i) {
//         vec2 offset = rot(2. * PI * i / SAMP_NUM) * initialOffset;
//         vec3 neighbourDir = normalize(getWorldPos(uv + offset) - centerPos);
//         float angleToNegihbour = acos(dot(toCamDir, neighbourDir));
//         angleSum += clamp(angleToNegihbour, 0., HALF_PI);
//     }
//     float ssaoValue = angleSum / SAMP_NUM / HALF_PI;
    
// #endif

    imageStore(res, pixelLocation, vec4(ssaoValue));
}